# coding: utf-8

"""
    Orders

    An order represents a payment between two or more parties. Use the Orders API to create, update, retrieve, authorize, and capture orders.

    The version of the OpenAPI document: 2.13
    Generated by: https://konfigthis.com
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from pay_pal_checkout_python_sdk import schemas  # noqa: F401


class OrdersCapture403(
    schemas.AnyTypeSchema,
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)
    """


    class MetaOapg:
        
        class properties:
            
            
            class details(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            
                            
                            class any_of_0(
                                schemas.AnyTypeSchema,
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class description(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "CONSENT_NEEDED": "CONSENT_NEEDED",
                                                }
                                            
                                            @schemas.classproperty
                                            def CONSENT_NEEDED(cls):
                                                return cls("CONSENT_NEEDED")
                                        
                                        
                                        class issue(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "CONSENT_NEEDED": "CONSENT_NEEDED",
                                                }
                                            
                                            @schemas.classproperty
                                            def CONSENT_NEEDED(cls):
                                                return cls("CONSENT_NEEDED")
                                        __annotations__ = {
                                            "description": description,
                                            "issue": issue,
                                        }
                            
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["issue"]) -> MetaOapg.properties.issue: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["issue"]) -> typing.Union[MetaOapg.properties.issue, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                    description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
                                    issue: typing.Union[MetaOapg.properties.issue, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'any_of_0':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        description=description,
                                        issue=issue,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            
                            class any_of_1(
                                schemas.AnyTypeSchema,
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class description(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "API caller is not enabled to process payments with the specified type of token. Please contact customer support to request permissions to process transactions with this type of token.": "API_CALLER_IS_NOT_ENABLED_TO_PROCESS_PAYMENTS_WITH_THE_SPECIFIED_TYPE_OF_TOKEN__PLEASE_CONTACT_CUSTOMER_SUPPORT_TO_REQUEST_PERMISSIONS_TO_PROCESS_TRANSACTIONS_WITH_THIS_TYPE_OF_TOKEN_",
                                                }
                                            
                                            @schemas.classproperty
                                            def API_CALLER_IS_NOT_ENABLED_TO_PROCESS_PAYMENTS_WITH_THE_SPECIFIED_TYPE_OF_TOKEN__PLEASE_CONTACT_CUSTOMER_SUPPORT_TO_REQUEST_PERMISSIONS_TO_PROCESS_TRANSACTIONS_WITH_THIS_TYPE_OF_TOKEN_(cls):
                                                return cls("API caller is not enabled to process payments with the specified type of token. Please contact customer support to request permissions to process transactions with this type of token.")
                                        
                                        
                                        class issue(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "NOT_ELIGIBLE_FOR_TOKEN_PROCESSING": "NOT_ELIGIBLE_FOR_TOKEN_PROCESSING",
                                                }
                                            
                                            @schemas.classproperty
                                            def NOT_ELIGIBLE_FOR_TOKEN_PROCESSING(cls):
                                                return cls("NOT_ELIGIBLE_FOR_TOKEN_PROCESSING")
                                        __annotations__ = {
                                            "description": description,
                                            "issue": issue,
                                        }
                            
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["issue"]) -> MetaOapg.properties.issue: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["issue"]) -> typing.Union[MetaOapg.properties.issue, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                    description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
                                    issue: typing.Union[MetaOapg.properties.issue, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'any_of_1':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        description=description,
                                        issue=issue,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            
                            class any_of_2(
                                schemas.AnyTypeSchema,
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class description(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "You do not have permission to access or perform operations on this resource.": "YOU_DO_NOT_HAVE_PERMISSION_TO_ACCESS_OR_PERFORM_OPERATIONS_ON_THIS_RESOURCE_",
                                                }
                                            
                                            @schemas.classproperty
                                            def YOU_DO_NOT_HAVE_PERMISSION_TO_ACCESS_OR_PERFORM_OPERATIONS_ON_THIS_RESOURCE_(cls):
                                                return cls("You do not have permission to access or perform operations on this resource.")
                                        
                                        
                                        class issue(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "PERMISSION_DENIED": "PERMISSION_DENIED",
                                                }
                                            
                                            @schemas.classproperty
                                            def PERMISSION_DENIED(cls):
                                                return cls("PERMISSION_DENIED")
                                        __annotations__ = {
                                            "description": description,
                                            "issue": issue,
                                        }
                            
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["issue"]) -> MetaOapg.properties.issue: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["issue"]) -> typing.Union[MetaOapg.properties.issue, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                    description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
                                    issue: typing.Union[MetaOapg.properties.issue, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'any_of_2':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        description=description,
                                        issue=issue,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            
                            class any_of_3(
                                schemas.AnyTypeSchema,
                            ):
                            
                            
                                class MetaOapg:
                                    
                                    class properties:
                                        
                                        
                                        class description(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "The API Caller or Payee have not been granted appropriate permissions to send 'items.category' as 'DONATION'. Please speak to your account manager if you want to process these type of items.": "THE_API_CALLER_OR_PAYEE_HAVE_NOT_BEEN_GRANTED_APPROPRIATE_PERMISSIONS_TO_SEND_ITEMS_CATEGORY_AS_DONATION__PLEASE_SPEAK_TO_YOUR_ACCOUNT_MANAGER_IF_YOU_WANT_TO_PROCESS_THESE_TYPE_OF_ITEMS_",
                                                }
                                            
                                            @schemas.classproperty
                                            def THE_API_CALLER_OR_PAYEE_HAVE_NOT_BEEN_GRANTED_APPROPRIATE_PERMISSIONS_TO_SEND_ITEMS_CATEGORY_AS_DONATION__PLEASE_SPEAK_TO_YOUR_ACCOUNT_MANAGER_IF_YOU_WANT_TO_PROCESS_THESE_TYPE_OF_ITEMS_(cls):
                                                return cls("The API Caller or Payee have not been granted appropriate permissions to send 'items.category' as 'DONATION'. Please speak to your account manager if you want to process these type of items.")
                                        
                                        
                                        class issue(
                                            schemas.EnumBase,
                                            schemas.StrSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                enum_value_to_name = {
                                                    "PERMISSION_DENIED_FOR_DONATION_ITEMS": "PERMISSION_DENIED_FOR_DONATION_ITEMS",
                                                }
                                            
                                            @schemas.classproperty
                                            def PERMISSION_DENIED_FOR_DONATION_ITEMS(cls):
                                                return cls("PERMISSION_DENIED_FOR_DONATION_ITEMS")
                                        __annotations__ = {
                                            "description": description,
                                            "issue": issue,
                                        }
                            
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
                                
                                @typing.overload
                                def __getitem__(self, name: typing_extensions.Literal["issue"]) -> MetaOapg.properties.issue: ...
                                
                                @typing.overload
                                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                
                                def __getitem__(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    # dict_instance[name] accessor
                                    return super().__getitem__(name)
                                
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: typing_extensions.Literal["issue"]) -> typing.Union[MetaOapg.properties.issue, schemas.Unset]: ...
                                
                                @typing.overload
                                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                
                                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["description", "issue", ], str]):
                                    return super().get_item_oapg(name)
                                
                            
                                def __new__(
                                    cls,
                                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                    description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
                                    issue: typing.Union[MetaOapg.properties.issue, str, schemas.Unset] = schemas.unset,
                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                ) -> 'any_of_3':
                                    return super().__new__(
                                        cls,
                                        *args,
                                        description=description,
                                        issue=issue,
                                        _configuration=_configuration,
                                        **kwargs,
                                    )
                            
                            @classmethod
                            @functools.lru_cache()
                            def any_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.any_of_0,
                                    cls.any_of_1,
                                    cls.any_of_2,
                                    cls.any_of_3,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'details':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            __annotations__ = {
                "details": details,
            }

    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["details"]) -> MetaOapg.properties.details: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["details", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["details"]) -> typing.Union[MetaOapg.properties.details, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["details", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        details: typing.Union[MetaOapg.properties.details, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'OrdersCapture403':
        return super().__new__(
            cls,
            *args,
            details=details,
            _configuration=_configuration,
            **kwargs,
        )
